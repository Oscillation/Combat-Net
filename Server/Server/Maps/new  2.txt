name << time << data










/*short input;
				int inputCount;
				bool move = false;
				sf::Vector2<float> vel;
				sf::String data;

				packet >> data >> inputCount;
				m_clientList[data.toAnsiString()].setPosition(m_clientList[data.toAnsiString()].getPosition());

				for (int i = 0; i < inputCount; i++)
				{
				packet >> input;
				switch (input)
				{
				case 0:
				vel.y -= 3;
				move = true;
				break;
				case 1:
				vel.y += 3;
				move = true;
				break;
				case 2:
				vel.x -= 3;
				move = true;
				break;
				case 3:
				vel.x += 3;
				move = true;
				break;
				default:
				break;
				}
				if (input == 4)
				{
				std::unique_ptr<Projectile> projectile(new Projectile());
				projectile->setPosition(m_clientList[data.toAnsiString()].getPosition());
				m_projectileList[data.toAnsiString()].push_back(std::move(projectile));
				projPacket << cn::Projectile << data << *m_projectileList[data.toAnsiString()].back();
				}
				if (input == 5)
				{
				std::unique_ptr<Projectile> projectile(new Projectile());
				projectile->setPosition(m_clientList[data.toAnsiString()].getPosition());
				m_projectileList[data.toAnsiString()].push_back(std::move(projectile));
				projPacket << cn::Projectile << data << *m_projectileList[data.toAnsiString()].back();
				}
				if (input == 6)
				{
				std::unique_ptr<Projectile> projectile(new Projectile());
				projectile->setPosition(m_clientList[data.toAnsiString()].getPosition());
				m_projectileList[data.toAnsiString()].push_back(std::move(projectile));
				projPacket << cn::Projectile << data << *m_projectileList[data.toAnsiString()].back();
				}
				if (input == 7)
				{
				std::unique_ptr<Projectile> projectile(new Projectile());
				projectile->setPosition(m_clientList[data.toAnsiString()].getPosition());
				m_projectileList[data.toAnsiString()].push_back(std::move(projectile));
				projPacket << cn::Projectile << data << *m_projectileList[data.toAnsiString()].back();
				}

				if (!map.intersectsWall(sf::Vector2<float>(m_clientList[data.toAnsiString()].getPosition().x, m_clientList[data.toAnsiString()].getPosition().y + vel.y)))
				{
				m_clientList[data.toAnsiString()].setPosition(sf::Vector2<float>(m_clientList[data.toAnsiString()].getPosition().x, m_clientList[data.toAnsiString()].getPosition().y + vel.y));
				}else
				{
				//resolve
				}
				if (!map.intersectsWall(sf::Vector2<float>(m_clientList[data.toAnsiString()].getPosition().x + vel.x, m_clientList[data.toAnsiString()].getPosition().y)))
				{
				m_clientList[data.toAnsiString()].setPosition(sf::Vector2<float>(m_clientList[data.toAnsiString()].getPosition().x + vel.x, m_clientList[data.toAnsiString()].getPosition().y));
				}else
				{
				//resolve
				}
				}
				if (move)
				{
				retPacket << cn::PlayerMove << data << m_clientList[data.toAnsiString()].getPosition().x << m_clientList[data.toAnsiString()].getPosition().y;
				}
				shouldSend = true;
				}*/ 